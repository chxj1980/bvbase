adler32.c:#if HAVE_FAST_64BIT && HAVE_FAST_UNALIGNED && !CONFIG_SMALL
adler32.c:#if HAVE_BIGENDIAN
aes.c:typedef struct BVAES {
aes.c:} BVAES;
aes.c:const int bv_aes_size= sizeof(BVAES);
aes.c:struct BVAES *bv_aes_alloc(void)
aes.c:    return bv_mallocz(sizeof(struct BVAES));
aes.c:#if HAVE_BIGENDIAN
aes.c:static inline void crypt(BVAES *a, int s, const uint8_t *sbox,
aes.c:void bv_aes_crypt(BVAES *a, uint8_t *dst, const uint8_t *src,
aes.c:int bv_aes_init(BVAES *a, const uint8_t *key, int key_bits, int decrypt)
aes.c:    BVAES b;
aes.c:        BVAES ae, ad;
aes.h:struct BVAES;
aes.h: * Allocate an BVAES context.
aes.h:struct BVAES *bv_aes_alloc(void);
aes.h: * Initialize an BVAES context.
aes.h:int bv_aes_init(struct BVAES *a, const uint8_t *key, int key_bits, int decrypt);
aes.h:void bv_aes_crypt(struct BVAES *a, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt);
匹配到二进制文件 aes.o
atomic.c:#if !HAVE_ATOMICS_NATIVE
atomic.c:#if HAVE_PTHREADS
atomic.c:#elif !HAVE_THREADS
atomic.c:#else /* HAVE_THREADS */
atomic.c:#endif /* HAVE_PTHREADS */
atomic.c:#endif /* !HAVE_ATOMICS_NATIVE */
atomic_gcc.h:#if HAVE_ATOMIC_COMPARE_EXCHANGE
atomic_gcc.h:#if HAVE_ATOMIC_COMPARE_EXCHANGE
atomic_gcc.h:#if HAVE_ATOMIC_COMPARE_EXCHANGE
atomic_gcc.h:#if HAVE_SYNC_VAL_COMPARE_AND_SWAP
atomic.h:#if HAVE_ATOMICS_NATIVE
atomic.h:#if HAVE_ATOMICS_GCC
atomic.h:#elif HAVE_ATOMICS_WIN32
atomic.h:#elif HAVE_ATOMICS_SUNCC
atomic.h:#endif /* HAVE_ATOMICS_NATIVE */
audio_fifo.c:struct BVAudioFifo {
audio_fifo.c:    BVFifoBuffer **buf;             /**< single buffer for interleaved, per-channel buffers for planar */
audio_fifo.c:void bv_audio_fifo_free(BVAudioFifo *af)
audio_fifo.c:BVAudioFifo *bv_audio_fifo_alloc(enum BVSampleFormat sample_fmt, int channels,
audio_fifo.c:    BVAudioFifo *af;
audio_fifo.c:int bv_audio_fifo_realloc(BVAudioFifo *af, int nb_samples)
audio_fifo.c:int bv_audio_fifo_write(BVAudioFifo *af, void **data, int nb_samples)
audio_fifo.c:int bv_audio_fifo_read(BVAudioFifo *af, void **data, int nb_samples)
audio_fifo.c:int bv_audio_fifo_drain(BVAudioFifo *af, int nb_samples)
audio_fifo.c:void bv_audio_fifo_reset(BVAudioFifo *af)
audio_fifo.c:int bv_audio_fifo_size(BVAudioFifo *af)
audio_fifo.c:int bv_audio_fifo_space(BVAudioFifo *af)
audio_fifo.h:typedef struct BVAudioFifo BVAudioFifo;
audio_fifo.h: * Free an BVAudioFifo.
audio_fifo.h: * @param af  BVAudioFifo to free
audio_fifo.h:void bv_audio_fifo_free(BVAudioFifo *af);
audio_fifo.h: * Allocate an BVAudioFifo.
audio_fifo.h: * @return            newly allocated BVAudioFifo, or NULL on error
audio_fifo.h:BVAudioFifo *bv_audio_fifo_alloc(enum BVSampleFormat sample_fmt, int channels,
audio_fifo.h: * Reallocate an BVAudioFifo.
audio_fifo.h: * @param af          BVAudioFifo to reallocate
audio_fifo.h:int bv_audio_fifo_realloc(BVAudioFifo *af, int nb_samples);
audio_fifo.h: * Write data to an BVAudioFifo.
audio_fifo.h: * The BVAudioFifo will be reallocated automatically if the available space
audio_fifo.h: * @param af          BVAudioFifo to write to
audio_fifo.h:int bv_audio_fifo_write(BVAudioFifo *af, void **data, int nb_samples);
audio_fifo.h: * Read data from an BVAudioFifo.
audio_fifo.h: * @param af          BVAudioFifo to read from
audio_fifo.h:int bv_audio_fifo_read(BVAudioFifo *af, void **data, int nb_samples);
audio_fifo.h: * Drain data from an BVAudioFifo.
audio_fifo.h: * @param af          BVAudioFifo to drain
audio_fifo.h:int bv_audio_fifo_drain(BVAudioFifo *af, int nb_samples);
audio_fifo.h: * Reset the BVAudioFifo buffer.
audio_fifo.h: * @param af  BVAudioFifo to reset
audio_fifo.h:void bv_audio_fifo_reset(BVAudioFifo *af);
audio_fifo.h: * Get the current number of samples in the BVAudioFifo available for reading.
audio_fifo.h: * @param af  the BVAudioFifo to query
audio_fifo.h:int bv_audio_fifo_size(BVAudioFifo *af);
audio_fifo.h: * Get the current number of samples in the BVAudioFifo available for writing.
audio_fifo.h: * @param af  the BVAudioFifo to query
audio_fifo.h:int bv_audio_fifo_space(BVAudioFifo *af);
匹配到二进制文件 audio_fifo.o
avassert.h:#ifndef BVUTIL_BVASSERT_H
avassert.h:#define BVUTIL_BVASSERT_H
avassert.h:#endif /* BVUTIL_BVASSERT_H */
bvstring.c:#if HAVE_DOS_PATHS
bvstring.c:#if HAVE_DOS_PATHS
bvstring.c:              enum BVEscapeMode mode, int flags)
bvstring.c:    BVBPrint dstbuf;
bvstring.h:#ifndef BVUTIL_AVSTRING_H
bvstring.h:#define BVUTIL_AVSTRING_H
bvstring.h:enum BVEscapeMode {
bvstring.h:              enum BVEscapeMode mode, int flags);
bvstring.h:#endif /* BVUTIL_AVSTRING_H */
匹配到二进制文件 bvstring.o
blowfish.c:bv_cold void bv_blowfish_init(BVBlowfish *ctx, const uint8_t *key, int key_len)
blowfish.c:void bv_blowfish_crypt_ecb(BVBlowfish *ctx, uint32_t *xl, uint32_t *xr,
blowfish.c:void bv_blowfish_crypt(BVBlowfish *ctx, uint8_t *dst, const uint8_t *src,
blowfish.c:static void test_blowfish(BVBlowfish *ctx, uint8_t *dst, const uint8_t *src,
blowfish.c:    BVBlowfish ctx;
blowfish.h:typedef struct BVBlowfish {
blowfish.h:} BVBlowfish;
blowfish.h: * Initialize an BVBlowfish context.
blowfish.h: * @param ctx an BVBlowfish context
blowfish.h:void bv_blowfish_init(struct BVBlowfish *ctx, const uint8_t *key, int key_len);
blowfish.h: * @param ctx an BVBlowfish context
blowfish.h:void bv_blowfish_crypt_ecb(struct BVBlowfish *ctx, uint32_t *xl, uint32_t *xr,
blowfish.h: * @param ctx an BVBlowfish context
blowfish.h:void bv_blowfish_crypt(struct BVBlowfish *ctx, uint8_t *dst, const uint8_t *src,
匹配到二进制文件 blowfish.o
bprint.c:static int bv_bprint_alloc(BVBPrint *buf, unsigned room)
bprint.c:static void bv_bprint_grow(BVBPrint *buf, unsigned extra_len)
bprint.c:void bv_bprint_init(BVBPrint *buf, unsigned size_init, unsigned size_max)
bprint.c:void bv_bprint_init_for_buffer(BVBPrint *buf, char *buffer, unsigned size)
bprint.c:void bv_bprintf(BVBPrint *buf, const char *fmt, ...)
bprint.c:void bv_vbprintf(BVBPrint *buf, const char *fmt, va_list vl_arg)
bprint.c:void bv_bprint_chars(BVBPrint *buf, char c, unsigned n)
bprint.c:void bv_bprint_append_data(BVBPrint *buf, const char *data, unsigned size)
bprint.c:void bv_bprint_strftime(BVBPrint *buf, const char *fmt, const struct tm *tm)
bprint.c:void bv_bprint_get_buffer(BVBPrint *buf, unsigned size,
bprint.c:void bv_bprint_clear(BVBPrint *buf)
bprint.c:int bv_bprint_finalize(BVBPrint *buf, char **ret_str)
bprint.c:void bv_bprint_escape(BVBPrint *dstbuf, const char *src, const char *special_chars,
bprint.c:                      enum BVEscapeMode mode, int flags)
bprint.c:static void bprint_pascal(BVBPrint *b, unsigned size)
bprint.c:    BVBPrint b;
bprint.h:FF_PAD_STRUCTURE(BVBPrint, 1024,
bprint.h:void bv_bprint_init(BVBPrint *buf, unsigned size_init, unsigned size_max);
bprint.h:void bv_bprint_init_for_buffer(BVBPrint *buf, char *buffer, unsigned size);
bprint.h:void bv_bprintf(BVBPrint *buf, const char *fmt, ...) bv_printf_format(2, 3);
bprint.h:void bv_vbprintf(BVBPrint *buf, const char *fmt, va_list vl_arg);
bprint.h:void bv_bprint_chars(BVBPrint *buf, char c, unsigned n);
bprint.h:void bv_bprint_append_data(BVBPrint *buf, const char *data, unsigned size);
bprint.h:void bv_bprint_strftime(BVBPrint *buf, const char *fmt, const struct tm *tm);
bprint.h:void bv_bprint_get_buffer(BVBPrint *buf, unsigned size,
bprint.h:void bv_bprint_clear(BVBPrint *buf);
bprint.h:static inline int bv_bprint_is_complete(const BVBPrint *buf)
bprint.h:int bv_bprint_finalize(BVBPrint *buf, char **ret_str);
bprint.h:void bv_bprint_escape(BVBPrint *dstbuf, const char *src, const char *special_chars,
bprint.h:                      enum BVEscapeMode mode, int flags);
匹配到二进制文件 bprint.o
bswap.h:#ifdef HAVE_BV_CONFIG_H
bswap.h:#elif ARCH_AVR32
bswap.h:#endif /* HAVE_BV_CONFIG_H */
bswap.h:#if BV_HAVE_BIGENDIAN
buffer.c:BVBufferRef *bv_buffer_create(uint8_t *data, int size,
buffer.c:    BVBufferRef *ref = NULL;
buffer.c:    BVBuffer    *buf = NULL;
buffer.c:BVBufferRef *bv_buffer_alloc(int size)
buffer.c:    BVBufferRef *ret = NULL;
buffer.c:BVBufferRef *bv_buffer_allocz(int size)
buffer.c:    BVBufferRef *ret = bv_buffer_alloc(size);
buffer.c:BVBufferRef *bv_buffer_ref(BVBufferRef *buf)
buffer.c:    BVBufferRef *ret = bv_mallocz(sizeof(*ret));
buffer.c:void bv_buffer_unref(BVBufferRef **buf)
buffer.c:    BVBuffer *b;
buffer.c:int bv_buffer_is_writable(const BVBufferRef *buf)
buffer.c:void *bv_buffer_get_opaque(const BVBufferRef *buf)
buffer.c:int bv_buffer_get_ref_count(const BVBufferRef *buf)
buffer.c:int bv_buffer_make_writable(BVBufferRef **pbuf)
buffer.c:    BVBufferRef *newbuf, *buf = *pbuf;
buffer.c:int bv_buffer_realloc(BVBufferRef **pbuf, int size)
buffer.c:    BVBufferRef *buf = *pbuf;
buffer.c:        BVBufferRef *new = NULL;
buffer.c:BVBufferPool *bv_buffer_pool_init(int size, BVBufferRef* (*alloc)(int size))
buffer.c:    BVBufferPool *pool = bv_mallocz(sizeof(*pool));
buffer.c:static void buffer_pool_free(BVBufferPool *pool)
buffer.c:void bv_buffer_pool_uninit(BVBufferPool **ppool)
buffer.c:    BVBufferPool *pool;
buffer.c:static BufferPoolEntry *get_pool(BVBufferPool *pool)
buffer.c:    BVBufferPool *pool;
buffer.c:    BVBufferPool *pool = buf->pool;
buffer.c:static BVBufferRef *pool_alloc_buffer(BVBufferPool *pool)
buffer.c:    BVBufferRef     *ret;
buffer.c:BVBufferRef *bv_buffer_pool_get(BVBufferPool *pool)
buffer.c:    BVBufferRef *ret;
buffer.h: * @defgroup lavu_buffer BVBuffer
buffer.h: * BVBuffer is an API for reference-counted data buffers.
buffer.h: * There are two core objects in this API -- BVBuffer and BVBufferRef. BVBuffer
buffer.h: * by the caller directly, but only through BVBufferRef. However, the caller may
buffer.h: * e.g. compare two BVBuffer pointers to check whether two different references
buffer.h: * are describing the same data buffer. BVBufferRef represents a single
buffer.h: * reference to an BVBuffer and it is the object that may be manipulated by the
buffer.h: * There are two functions provided for creating a new BVBuffer with a single
buffer.h: * bv_buffer_create() to wrap an existing array in an BVBuffer. From an existing
buffer.h: * parts of the buffer (i.e. their BVBufferRef.data will not be equal).
buffer.h: * references (BVBufferRef).
buffer.h:typedef struct BVBuffer BVBuffer;
buffer.h:typedef struct BVBufferRef {
buffer.h:    BVBuffer *buffer;
buffer.h:} BVBufferRef;
buffer.h: * Allocate an BVBuffer of the given size using bv_malloc().
buffer.h: * @return an BVBufferRef of given size or NULL when out of memory
buffer.h:BVBufferRef *bv_buffer_alloc(int size);
buffer.h:BVBufferRef *bv_buffer_allocz(int size);
buffer.h: * Create an BVBuffer from an existing array.
buffer.h: * If this function is successful, data is owned by the BVBuffer. The caller may
buffer.h: * only access data through the returned BVBufferRef and references derived from
buffer.h: * @return an BVBufferRef referring to data on success, NULL on failure.
buffer.h:BVBufferRef *bv_buffer_create(uint8_t *data, int size,
buffer.h: * Create a new reference to an BVBuffer.
buffer.h: * @return a new BVBufferRef referring to the same BVBuffer as buf or NULL on
buffer.h:BVBufferRef *bv_buffer_ref(BVBufferRef *buf);
buffer.h:void bv_buffer_unref(BVBufferRef **buf);
buffer.h: * true if and only if buf is the only reference to the underlying BVBuffer).
buffer.h:int bv_buffer_is_writable(const BVBufferRef *buf);
buffer.h:void *bv_buffer_get_opaque(const BVBufferRef *buf);
buffer.h:int bv_buffer_get_ref_count(const BVBufferRef *buf);
buffer.h: *            untouched, or it is unreferenced and a new writable BVBufferRef is
buffer.h:int bv_buffer_make_writable(BVBufferRef **buf);
buffer.h:int bv_buffer_realloc(BVBufferRef **buf, int size);
buffer.h: * @defgroup lavu_bufferpool BVBufferPool
buffer.h: * BVBufferPool is an API for a lock-free thread-safe pool of BVBuffers.
buffer.h: * Frequently allocating and freeing large buffers may be slow. BVBufferPool is
buffer.h:typedef struct BVBufferPool BVBufferPool;
buffer.h:BVBufferPool *bv_buffer_pool_init(int size, BVBufferRef* (*alloc)(int size));
buffer.h:void bv_buffer_pool_uninit(BVBufferPool **pool);
buffer.h: * Allocate a new BVBuffer, reusing an old buffer from the pool when available.
buffer.h:BVBufferRef *bv_buffer_pool_get(BVBufferPool *pool);
buffer_internal.h:struct BVBuffer {
buffer_internal.h:     *  number of existing BVBufferRef instances referring to this buffer
buffer_internal.h:     * Backups of the original opaque/free of the BVBuffer corresponding to
buffer_internal.h:    BVBufferPool *pool;
buffer_internal.h:struct BVBufferPool {
buffer_internal.h:    AVMutex mutex;
buffer_internal.h:    BVBufferRef* (*alloc)(int size);
匹配到二进制文件 buffer.o
bvconfig.h:#ifndef BVUTIL_BVCONFIG_H
bvconfig.h:#define BVUTIL_BVCONFIG_H
bvconfig.h:#define BV_HAVE_BIGENDIAN 0
bvconfig.h:#define BV_HAVE_FAST_UNALIGNED 1
bvconfig.h:#define BV_HAVE_INCOMPATIBLE_LIBBV_ABI 0
bvconfig.h:#endif /* BVUTIL_BVCONFIG_H */
bvutil.h:enum BVMediaType {
bvutil.h:const char *bv_get_media_type_string(enum BVMediaType media_type);
bvutil.h: * BVPicture types, pixel formats and basic image planes manipulation.
bvutil.h:enum BVPictureType {
bvutil.h:char bv_get_picture_type_char(enum BVPictureType pict_type);
cast5.c:typedef struct BVCAST5 {
cast5.c:} BVCAST5;
cast5.c:const int bv_cast5_size = sizeof(BVCAST5);
cast5.c:static void encipher(BVCAST5* cs, uint8_t* dst, const uint8_t* src)
cast5.c:static void decipher(BVCAST5* cs, uint8_t* dst, const uint8_t* src, uint8_t *iv)
cast5.c:struct BVCAST5 *bv_cast5_alloc(void)
cast5.c:    return bv_mallocz(sizeof(struct BVCAST5));
cast5.c:bv_cold int bv_cast5_init(BVCAST5* cs, const uint8_t *key, int key_bits)
cast5.c:void bv_cast5_crypt2(BVCAST5* cs, uint8_t* dst, const uint8_t* src, int count, uint8_t *iv, int decrypt)
cast5.c:void bv_cast5_crypt(BVCAST5* cs, uint8_t* dst, const uint8_t* src, int count, int decrypt)
cast5.c:    BVCAST5 *cs;
cast5.h:struct BVCAST5;
cast5.h:  * Allocate an BVCAST5 context
cast5.h:struct BVCAST5 *bv_cast5_alloc(void);
cast5.h:  * Initialize an BVCAST5 context.
cast5.h:  * @param ctx an BVCAST5 context
cast5.h:int bv_cast5_init(struct BVCAST5 *ctx, const uint8_t *key, int key_bits);
cast5.h:  * @param ctx an BVCAST5 context
cast5.h:void bv_cast5_crypt(struct BVCAST5 *ctx, uint8_t *dst, const uint8_t *src, int count, int decrypt);
cast5.h:  * @param ctx an BVCAST5 context
cast5.h:void bv_cast5_crypt2(struct BVCAST5 *ctx, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt);
匹配到二进制文件 cast5.o
channel_layout.c:void bv_bprint_channel_layout(struct BVBPrint *bp,
channel_layout.c:    BVBPrint bp;
channel_layout.h:/** Channel mask value used for BVCodecContext.request_channel_layout
channel_layout.h:enum AVMatrixEncoding {
channel_layout.h:struct BVBPrint;
channel_layout.h:void bv_bprint_channel_layout(struct BVBPrint *bp, int nb_channels, uint64_t channel_layout);
匹配到二进制文件 channel_layout.o
common.h:#if BV_HAVE_BIGENDIAN
common.h:#ifdef HAVE_BV_CONFIG_H
common.h:#if defined(HAVE_BV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
common.h:#if defined(HAVE_BV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
common.h:#if defined(HAVE_BV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
common.h:#if defined(HAVE_BV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
common.h:#ifdef HAVE_BV_CONFIG_H
common.h:#endif /* HAVE_BV_CONFIG_H */
cpu.c:#if HAVE_SCHED_GETAFFINITY
cpu.c:#if HAVE_GETPROCESSAFFINITYMASK
cpu.c:#if HAVE_SYSCTL
cpu.c:#if HAVE_SYS_PARAM_H
cpu.c:#if HAVE_UNISTD_H
cpu.c:                    BV_CPU_FLAG_AVX      |
cpu.c:                    BV_CPU_FLAG_AVX2     ))
cpu.c:#define CPUFLAG_AVX      (BV_CPU_FLAG_AVX      | CPUFLAG_SSE42)
cpu.c:#define CPUFLAG_XOP      (BV_CPU_FLAG_XOP      | CPUFLAG_AVX)
cpu.c:#define CPUFLAG_FMA3     (BV_CPU_FLAG_FMA3     | CPUFLAG_AVX)
cpu.c:#define CPUFLAG_FMA4     (BV_CPU_FLAG_FMA4     | CPUFLAG_AVX)
cpu.c:#define CPUFLAG_AVX2     (BV_CPU_FLAG_AVX2     | CPUFLAG_AVX)
cpu.c:        { "avx"     , NULL, 0, BV_OPT_TYPE_CONST, { .i64 = CPUFLAG_AVX          },    .unit = "flags" },
cpu.c:        { "avx2"    , NULL, 0, BV_OPT_TYPE_CONST, { .i64 = CPUFLAG_AVX2         },    .unit = "flags" },
cpu.c:        { "avx"     , NULL, 0, BV_OPT_TYPE_CONST, { .i64 = BV_CPU_FLAG_AVX      },    .unit = "flags" },
cpu.c:        { "avx2"    , NULL, 0, BV_OPT_TYPE_CONST, { .i64 = BV_CPU_FLAG_AVX2     },    .unit = "flags" },
cpu.c:#if HAVE_SCHED_GETAFFINITY && defined(CPU_COUNT)
cpu.c:#elif HAVE_GETPROCESSAFFINITYMASK
cpu.c:#elif HAVE_SYSCTL && defined(HW_NCPU)
cpu.c:#elif HAVE_SYSCONF && defined(_SC_NPROC_ONLN)
cpu.c:#elif HAVE_SYSCONF && defined(_SC_NPROCESSORS_ONLN)
cpu.c:#if !HAVE_GETOPT
cpu.c:    { BV_CPU_FLAG_AVX,       "avx"        },
cpu.c:    { BV_CPU_FLAG_AVX2,      "avx2"       },
cpu.h:#define BV_CPU_FLAG_AVX          0x4000 ///< AVX functions: requires OS support even if YMM registers aren't used
cpu.h:#define BV_CPU_FLAG_AVX2         0x8000 ///< AVX2 functions: requires OS support even if YMM registers aren't used
cpu_internal.h:    (HAVE_ ## cpuext ## suffix && ((flags) & BV_CPU_FLAG_ ## cpuext))
匹配到二进制文件 cpu.o
crc.c:static const BVCRC bv_crc_table[BV_CRC_MAX][257] = {
crc.c:static BVCRC bv_crc_table[BV_CRC_MAX][CRC_TABLE_SIZE];
crc.c:int bv_crc_init(BVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size)
crc.c:    if (ctx_size != sizeof(BVCRC) * 257 && ctx_size != sizeof(BVCRC) * 1024)
crc.c:    if (ctx_size >= sizeof(BVCRC) * 1024)
crc.c:const BVCRC *bv_crc_get_table(BVCRCId crc_id)
crc.c:uint32_t bv_crc(const BVCRC *ctx, uint32_t crc,
crc.c:    const BVCRC *ctx;
crc.h:typedef uint32_t BVCRC;
crc.h:}BVCRCId;
crc.h: * @param ctx must be an array of size sizeof(BVCRC)*257 or sizeof(BVCRC)*1024
crc.h:int bv_crc_init(BVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size);
crc.h:const BVCRC *bv_crc_get_table(BVCRCId crc_id);
crc.h:uint32_t bv_crc(const BVCRC *ctx, uint32_t crc,
匹配到二进制文件 crc.o
des.c:typedef struct BVDES BVDES;
des.c:int bv_des_init(BVDES *d, const uint8_t *key, int key_bits, bv_unused int decrypt) {
des.c:static void bv_des_crypt_mac(BVDES *d, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt, int mac) {
des.c:void bv_des_crypt(BVDES *d, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt) {
des.c:void bv_des_mac(BVDES *d, uint8_t *dst, const uint8_t *src, int count) {
des.c:    BVDES d;
des.c:    BVDES d;
des.h:struct BVDES {
des.h: * @brief Initializes an BVDES context.
des.h:int bv_des_init(struct BVDES *d, const uint8_t *key, int key_bits, int decrypt);
des.h:void bv_des_crypt(struct BVDES *d, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt);
des.h:void bv_des_mac(struct BVDES *d, uint8_t *dst, const uint8_t *src, int count);
匹配到二进制文件 des.o
dict.c:    BVBPrint bprint;
dict.h: *  where applicable, which uses AVL trees to achieve O(log n) performance.
匹配到二进制文件 dict.o
downmix_info.c:AVDownmixInfo *bv_downmix_info_update_side_data(BVFrame *frame)
downmix_info.c:                                           sizeof(AVDownmixInfo));
downmix_info.c:    return (AVDownmixInfo*)side_data->data;
downmix_info.h:enum AVDownmixType {
downmix_info.h:typedef struct AVDownmixInfo {
downmix_info.h:    enum AVDownmixType preferred_downmix_type;
downmix_info.h:} AVDownmixInfo;
downmix_info.h: * @return the AVDownmixInfo structure to be edited by the caller, or NULL if
downmix_info.h:AVDownmixInfo *bv_downmix_info_update_side_data(BVFrame *frame);
匹配到二进制文件 downmix_info.o
error.c:#if HAVE_STRERROR_R
error.c:        ret = BVERROR(strerror_r(AVUNERROR(errnum), errbuf, errbuf_size));
error.h:#define AVUNERROR(e) (-(e)) ///< Returns a POSIX error code from a library function error return value.
error.h:#define AVUNERROR(e) (e)
eval.c:struct AVExpr {
eval.c:    struct AVExpr *param[3];
eval.c:static double eval_expr(Parser *p, AVExpr *e)
eval.c:static int parse_expr(AVExpr **e, Parser *p);
eval.c:void bv_expr_free(AVExpr *e)
eval.c:static int parse_primary(AVExpr **e, Parser *p)
eval.c:    AVExpr *d = bv_mallocz(sizeof(AVExpr));
eval.c:static AVExpr *make_eval_expr(int type, int value, AVExpr *p0, AVExpr *p1)
eval.c:    AVExpr *e = bv_mallocz(sizeof(AVExpr));
eval.c:static int parse_pow(AVExpr **e, Parser *p, int *sign)
eval.c:static int parse_dB(AVExpr **e, Parser *p, int *sign)
eval.c:static int parse_factor(AVExpr **e, Parser *p)
eval.c:    AVExpr *e0, *e1, *e2;
eval.c:static int parse_term(AVExpr **e, Parser *p)
eval.c:    AVExpr *e0, *e1, *e2;
eval.c:static int parse_subexpr(AVExpr **e, Parser *p)
eval.c:    AVExpr *e0, *e1, *e2;
eval.c:static int parse_expr(AVExpr **e, Parser *p)
eval.c:    AVExpr *e0, *e1, *e2;
eval.c:static int verify_expr(AVExpr *e)
eval.c:int bv_expr_parse(AVExpr **expr, const char *s,
eval.c:    AVExpr *e = NULL;
eval.c:double bv_expr_eval(AVExpr *e, const double *const_values, void *opaque)
eval.c:    AVExpr *e = NULL;
eval.h:typedef struct AVExpr AVExpr;
eval.h: * @param expr a pointer where is put an AVExpr containing the parsed
eval.h: * The pointed to AVExpr must be freed with bv_expr_free() by the user
eval.h:int bv_expr_parse(AVExpr **expr, const char *s,
eval.h:double bv_expr_eval(AVExpr *e, const double *const_values, void *opaque);
eval.h:void bv_expr_free(AVExpr *e);
匹配到二进制文件 eval.o
fifo.c:static BVFifoBuffer *fifo_alloc_common(void *buffer, size_t size)
fifo.c:    BVFifoBuffer *f;
fifo.c:    f = bv_mallocz(sizeof(BVFifoBuffer));
fifo.c:BVFifoBuffer *bv_fifo_alloc(unsigned int size)
fifo.c:BVFifoBuffer *bv_fifo_alloc_array(size_t nmemb, size_t size)
fifo.c:void bv_fifo_free(BVFifoBuffer *f)
fifo.c:void bv_fifo_freep(BVFifoBuffer **f)
fifo.c:void bv_fifo_reset(BVFifoBuffer *f)
fifo.c:int bv_fifo_size(const BVFifoBuffer *f)
fifo.c:int bv_fifo_space(const BVFifoBuffer *f)
fifo.c:int bv_fifo_realloc2(BVFifoBuffer *f, unsigned int new_size)
fifo.c:        BVFifoBuffer *f2 = bv_fifo_alloc(new_size);
fifo.c:int bv_fifo_grow(BVFifoBuffer *f, unsigned int size)
fifo.c:int bv_fifo_generic_write(BVFifoBuffer *f, void *src, int size,
fifo.c:int bv_fifo_generic_read(BVFifoBuffer *f, void *dest, int buf_size,
fifo.c:void bv_fifo_drain(BVFifoBuffer *f, int size)
fifo.c:    BVFifoBuffer *fifo = bv_fifo_alloc(13 * sizeof(int));
fifo.h:typedef struct BVFifoBuffer {
fifo.h:} BVFifoBuffer;
fifo.h: * Initialize an BVFifoBuffer.
fifo.h: * @return BVFifoBuffer or NULL in case of memory allocation failure
fifo.h:BVFifoBuffer *bv_fifo_alloc(unsigned int size);
fifo.h: * Initialize an BVFifoBuffer.
fifo.h: * @return BVFifoBuffer or NULL in case of memory allocation failure
fifo.h:BVFifoBuffer *bv_fifo_alloc_array(size_t nmemb, size_t size);
fifo.h: * Free an BVFifoBuffer.
fifo.h: * @param f BVFifoBuffer to free
fifo.h:void bv_fifo_free(BVFifoBuffer *f);
fifo.h: * Free an BVFifoBuffer and reset pointer to NULL.
fifo.h: * @param f BVFifoBuffer to free
fifo.h:void bv_fifo_freep(BVFifoBuffer **f);
fifo.h: * Reset the BVFifoBuffer to the state right after bv_fifo_alloc, in particular it is emptied.
fifo.h: * @param f BVFifoBuffer to reset
fifo.h:void bv_fifo_reset(BVFifoBuffer *f);
fifo.h: * Return the amount of data in bytes in the BVFifoBuffer, that is the
fifo.h: * @param f BVFifoBuffer to read from
fifo.h:int bv_fifo_size(const BVFifoBuffer *f);
fifo.h: * Return the amount of space in bytes in the BVFifoBuffer, that is the
fifo.h: * @param f BVFifoBuffer to write into
fifo.h:int bv_fifo_space(const BVFifoBuffer *f);
fifo.h: * Feed data from an BVFifoBuffer to a user-supplied callback.
fifo.h: * @param f BVFifoBuffer to read from
fifo.h:int bv_fifo_generic_read(BVFifoBuffer *f, void *dest, int buf_size, void (*func)(void*, void*, int));
fifo.h: * Feed data from a user-supplied callback to an BVFifoBuffer.
fifo.h: * @param f BVFifoBuffer to write to
fifo.h:int bv_fifo_generic_write(BVFifoBuffer *f, void *src, int size, int (*func)(void*, void*, int));
fifo.h: * Resize an BVFifoBuffer.
fifo.h: * @param f BVFifoBuffer to resize
fifo.h: * @param size new BVFifoBuffer size in bytes
fifo.h:int bv_fifo_realloc2(BVFifoBuffer *f, unsigned int size);
fifo.h: * Enlarge an BVFifoBuffer.
fifo.h: * @param f BVFifoBuffer to resize
fifo.h:int bv_fifo_grow(BVFifoBuffer *f, unsigned int additional_space);
fifo.h: * Read and discard the specified amount of data from an BVFifoBuffer.
fifo.h: * @param f BVFifoBuffer to read from
fifo.h:void bv_fifo_drain(BVFifoBuffer *f, int size);
fifo.h: * @param f    BVFifoBuffer to peek at, f must be non-NULL
fifo.h:static inline uint8_t *bv_fifo_peek2(const BVFifoBuffer *f, int offs)
匹配到二进制文件 fifo.o
file.c:#if HAVE_UNISTD_H
file.c:#if HAVE_IO_H
file.c:#if HAVE_MMAP
file.c:#elif HAVE_MAPVIEWOFFILE
file.c:#if HAVE_MMAP
file.c:#elif HAVE_MAPVIEWOFFILE
file.c:#if HAVE_MMAP
file.c:#elif HAVE_MAPVIEWOFFILE
file.c:#if !HAVE_MKSTEMP
file.c:#if !HAVE_MKSTEMP
file_open.c:#if HAVE_UNISTD_H
file_open.c:#if HAVE_IO_H
file_open.c:#if HAVE_FCNTL
fixed_dsp.c:BVFixedDSPContext * bvpriv_alloc_fixed_dsp(int bit_exact)
fixed_dsp.c:    BVFixedDSPContext * fdsp = bv_malloc(sizeof(BVFixedDSPContext));
fixed_dsp.h:typedef struct BVFixedDSPContext {
fixed_dsp.h:} BVFixedDSPContext;
fixed_dsp.h:BVFixedDSPContext * bvpriv_alloc_fixed_dsp(int strict);
float_dsp.c:bv_cold void bvpriv_float_dsp_init(BVFloatDSPContext *fdsp, int bit_exact)
float_dsp.c:bv_cold BVFloatDSPContext *bvpriv_float_dsp_alloc(int bit_exact)
float_dsp.c:    BVFloatDSPContext *ret = bv_mallocz(sizeof(BVFloatDSPContext));
float_dsp.c:#if HAVE_UNISTD_H
float_dsp.c:#if !HAVE_GETOPT
float_dsp.c:static int test_vector_fmul(BVFloatDSPContext *fdsp, BVFloatDSPContext *cdsp,
float_dsp.c:static int test_vector_fmac_scalar(BVFloatDSPContext *fdsp, BVFloatDSPContext *cdsp,
float_dsp.c:static int test_vector_fmul_scalar(BVFloatDSPContext *fdsp, BVFloatDSPContext *cdsp,
float_dsp.c:static int test_vector_dmul_scalar(BVFloatDSPContext *fdsp, BVFloatDSPContext *cdsp,
float_dsp.c:static int test_vector_fmul_window(BVFloatDSPContext *fdsp, BVFloatDSPContext *cdsp,
float_dsp.c:static int test_vector_fmul_add(BVFloatDSPContext *fdsp, BVFloatDSPContext *cdsp,
float_dsp.c:static int test_vector_fmul_reverse(BVFloatDSPContext *fdsp, BVFloatDSPContext *cdsp,
float_dsp.c:static int test_butterflies_float(BVFloatDSPContext *fdsp, BVFloatDSPContext *cdsp,
float_dsp.c:static int test_scalarproduct_float(BVFloatDSPContext *fdsp, BVFloatDSPContext *cdsp,
float_dsp.c:    BVFloatDSPContext fdsp, cdsp;
float_dsp.h:typedef struct BVFloatDSPContext {
float_dsp.h:} BVFloatDSPContext;
float_dsp.h:void bvpriv_float_dsp_init(BVFloatDSPContext *fdsp, int strict);
float_dsp.h:void ff_float_dsp_init_aarch64(BVFloatDSPContext *fdsp);
float_dsp.h:void ff_float_dsp_init_arm(BVFloatDSPContext *fdsp);
float_dsp.h:void ff_float_dsp_init_ppc(BVFloatDSPContext *fdsp, int strict);
float_dsp.h:void ff_float_dsp_init_x86(BVFloatDSPContext *fdsp);
float_dsp.h:void ff_float_dsp_init_mips(BVFloatDSPContext *fdsp);
float_dsp.h:BVFloatDSPContext *bvpriv_float_dsp_alloc(int strict);
匹配到二进制文件 float_dsp.o
frame.c:MAKE_ACCESSORS(BVFrame, frame, enum BVColorSpace, colorspace)
frame.c:MAKE_ACCESSORS(BVFrame, frame, enum BVColorRange, color_range)
frame.c:int bv_frame_set_qp_table(BVFrame *f, BVBufferRef *buf, int stride, int qp_type)
frame.c:const char *bv_get_colorspace_name(enum BVColorSpace val)
frame.c:    const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(frame->format);
frame.c:#if FF_API_BVFRAME_LBVC
frame.c:BVBufferRef *bv_frame_get_plane_buffer(BVFrame *frame, int plane)
frame.c:        BVBufferRef *buf = frame->buf[i];
frame.c:        BVBufferRef *buf = frame->extended_buf[i];
frame.c:    case BV_FRAME_DATA_PANSCAN:         return "BVPanScan";
frame.c:    case BV_FRAME_DATA_MATRIXENCODING:  return "AVMatrixEncoding";
frame.h:     * The data is the BVPanScan struct defined in libavcodec.
frame.h:     * The data is the AVMatrixEncoding enum defined in libbvutil/channel_layout.h.
frame.h:     * The data is the AVDownmixInfo struct defined in libbvutil/downmix_info.h.
frame.h:     * in ETSI TS 101 154 using BVActiveFormatDescription enum.
frame.h:     * flag set in the libavcodec BVCodecContext flags2 option).
frame.h:     * The data is the AVMotionVector struct defined in
frame.h:enum BVActiveFormatDescription {
frame.h: * BVBuffer API. The underlying buffer references are stored in BVFrame.buf /
frame.h:     * Values correspond to enum BVPixelFormat for video frames,
frame.h:    enum BVPictureType pict_type;
frame.h:#if FF_API_BVFRAME_LBVC
frame.h:     * PTS copied from the BVPacket that was decoded to produce this frame.
frame.h:     * DTS copied from the BVPacket that triggered returning this frame. (if frame threading isn't used)
frame.h:     * only BVPacket.dts values without pts values.
frame.h:#if FF_API_BVFRAME_LBVC
frame.h:#if FF_API_BVFRAME_LBVC
frame.h:#if FF_API_BVFRAME_LBVC
frame.h:    struct BVPanScan *pan_scan;
frame.h:     * The user sets BVCodecContext.reordered_opaque to represent the input at
frame.h:     * to exactly one of the values provided by the user through BVCodecContext.reordered_opaque
frame.h:#if FF_API_BVFRAME_LBVC
frame.h:    struct BVCodecContext *owner;
frame.h:     * BVBuffer references backing the data for this frame. If all elements of
frame.h:     * There may be at most one BVBuffer per data plane, so for video this array
frame.h:     * this array. Then the extra BVBufferRef pointers are stored in the
frame.h:    BVBufferRef *buf[BV_NUM_DATA_POINTERS];
frame.h:     * BVBufferRef pointers, this array will hold all the references which
frame.h:    BVBufferRef **extended_buf;
frame.h:    enum BVColorRange color_range;
frame.h:    enum BVColorTransferCharacteristic color_trc;
frame.h:    enum BVColorSpace colorspace;
frame.h:    enum BVChromaLocation chroma_location;
frame.h:     * reordered pos from the last BVPacket that has been input into the decoder
frame.h:     * AVStream->time_base units, 0 if unknown.
frame.h:    BVBufferRef *qp_table_buf;
frame.h:int bv_frame_set_qp_table(BVFrame *f, BVBufferRef *buf, int stride, int type);
frame.h:enum BVColorSpace bv_frame_get_colorspace(const BVFrame *frame);
frame.h:void    bv_frame_set_colorspace(BVFrame *frame, enum BVColorSpace val);
frame.h:enum BVColorRange bv_frame_get_color_range(const BVFrame *frame);
frame.h:void    bv_frame_set_color_range(BVFrame *frame, enum BVColorRange val);
frame.h:const char *bv_get_colorspace_name(enum BVColorSpace val);
frame.h: * BVBufferRef from src.
frame.h: * of the underlying BVBufferRefs (e.g. through bv_frame_ref() or directly).
frame.h:BVBufferRef *bv_frame_get_plane_buffer(BVFrame *frame, int plane);
匹配到二进制文件 frame.o
hash.c:typedef struct BVHashContext {
hash.c:    const BVCRC *crctab;
hash.c:} BVHashContext;
hash.c:const char *bv_hash_get_name(const BVHashContext *ctx)
hash.c:int bv_hash_get_size(const BVHashContext *ctx)
hash.c:int bv_hash_alloc(BVHashContext **ctx, const char *name)
hash.c:    BVHashContext *res;
hash.c:void bv_hash_init(BVHashContext *ctx)
hash.c:void bv_hash_update(BVHashContext *ctx, const uint8_t *src, int len)
hash.c:void bv_hash_final(BVHashContext *ctx, uint8_t *dst)
hash.c:void bv_hash_final_bin(struct BVHashContext *ctx, uint8_t *dst, int size)
hash.c:void bv_hash_final_hex(struct BVHashContext *ctx, uint8_t *dst, int size)
hash.c:void bv_hash_final_b64(struct BVHashContext *ctx, uint8_t *dst, int size)
hash.c:void bv_hash_freep(BVHashContext **ctx)
hash.h:struct BVHashContext;
hash.h:int bv_hash_alloc(struct BVHashContext **ctx, const char *name);
hash.h:const char *bv_hash_get_name(const struct BVHashContext *ctx);
hash.h:int bv_hash_get_size(const struct BVHashContext *ctx);
hash.h:void bv_hash_init(struct BVHashContext *ctx);
hash.h:void bv_hash_update(struct BVHashContext *ctx, const uint8_t *src, int len);
hash.h:void bv_hash_final(struct BVHashContext *ctx, uint8_t *dst);
hash.h:void bv_hash_final_bin(struct BVHashContext *ctx, uint8_t *dst, int size);
hash.h:void bv_hash_final_hex(struct BVHashContext *ctx, uint8_t *dst, int size);
hash.h:void bv_hash_final_b64(struct BVHashContext *ctx, uint8_t *dst, int size);
hash.h:void bv_hash_freep(struct BVHashContext **ctx);
匹配到二进制文件 hash.o
hmac.c:struct BVHMAC {
hmac.c:BVHMAC *bv_hmac_alloc(enum BVHMACType type)
hmac.c:    BVHMAC *c = bv_mallocz(sizeof(*c));
hmac.c:void bv_hmac_free(BVHMAC *c)
hmac.c:void bv_hmac_init(BVHMAC *c, const uint8_t *key, unsigned int keylen)
hmac.c:void bv_hmac_update(BVHMAC *c, const uint8_t *data, unsigned int len)
hmac.c:int bv_hmac_final(BVHMAC *c, uint8_t *out, unsigned int outlen)
hmac.c:int bv_hmac_calc(BVHMAC *c, const uint8_t *data, unsigned int len,
hmac.c:static void test(BVHMAC *hmac, const uint8_t *key, int keylen,
hmac.c:    enum BVHMACType i = BV_HMAC_SHA224;
hmac.c:    BVHMAC *hmac = bv_hmac_alloc(BV_HMAC_MD5);
hmac.h:enum BVHMACType {
hmac.h:typedef struct BVHMAC BVHMAC;
hmac.h: * Allocate an BVHMAC context.
hmac.h:BVHMAC *bv_hmac_alloc(enum BVHMACType type);
hmac.h: * Free an BVHMAC context.
hmac.h:void bv_hmac_free(BVHMAC *ctx);
hmac.h: * Initialize an BVHMAC context with an authentication key.
hmac.h:void bv_hmac_init(BVHMAC *ctx, const uint8_t *key, unsigned int keylen);
hmac.h:void bv_hmac_update(BVHMAC *ctx, const uint8_t *data, unsigned int len);
hmac.h:int bv_hmac_final(BVHMAC *ctx, uint8_t *out, unsigned int outlen);
hmac.h:int bv_hmac_calc(BVHMAC *ctx, const uint8_t *data, unsigned int len,
匹配到二进制文件 hmac.o
imgutils.c:                                const BVPixFmtDescriptor *pixdesc)
imgutils.c:        const BVComponentDescriptor *comp = &(pixdesc->comp[i]);
imgutils.c:                       const BVPixFmtDescriptor *desc)
imgutils.c:int bv_image_get_linesize(enum BVPixelFormat pix_fmt, int width, int plane)
imgutils.c:    const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(pix_fmt);
imgutils.c:int bv_image_fill_linesizes(int linesizes[4], enum BVPixelFormat pix_fmt, int width)
imgutils.c:    const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(pix_fmt);
imgutils.c:int bv_image_fill_pointers(uint8_t *data[4], enum BVPixelFormat pix_fmt, int height,
imgutils.c:    const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(pix_fmt);
imgutils.c:int bvpriv_set_systematic_pal2(uint32_t pal[256], enum BVPixelFormat pix_fmt)
imgutils.c:                   int w, int h, enum BVPixelFormat pix_fmt, int align)
imgutils.c:    const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(pix_fmt);
imgutils.c:                   enum BVPixelFormat pix_fmt, int width, int height)
imgutils.c:    const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(pix_fmt);
imgutils.c:                         enum BVPixelFormat pix_fmt, int width, int height, int align)
imgutils.c:int bv_image_get_buffer_size(enum BVPixelFormat pix_fmt, int width, int height, int align)
imgutils.c:    const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(pix_fmt);
imgutils.c:                            enum BVPixelFormat pix_fmt, int width, int height, int align)
imgutils.c:    const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(pix_fmt);
imgutils.h:                                const BVPixFmtDescriptor *pixdesc);
imgutils.h:int bv_image_get_linesize(enum BVPixelFormat pix_fmt, int width, int plane);
imgutils.h:int bv_image_fill_linesizes(int linesizes[4], enum BVPixelFormat pix_fmt, int width);
imgutils.h:int bv_image_fill_pointers(uint8_t *data[4], enum BVPixelFormat pix_fmt, int height,
imgutils.h:                   int w, int h, enum BVPixelFormat pix_fmt, int align);
imgutils.h:                   enum BVPixelFormat pix_fmt, int width, int height);
imgutils.h:                         enum BVPixelFormat pix_fmt, int width, int height, int align);
imgutils.h:int bv_image_get_buffer_size(enum BVPixelFormat pix_fmt, int width, int height, int align);
imgutils.h:                            enum BVPixelFormat pix_fmt, int width, int height, int align);
匹配到二进制文件 imgutils.o
integer.c:BVInteger bv_add_i(BVInteger a, BVInteger b){
integer.c:BVInteger bv_sub_i(BVInteger a, BVInteger b){
integer.c:int bv_log2_i(BVInteger a){
integer.c:BVInteger bv_mul_i(BVInteger a, BVInteger b){
integer.c:    BVInteger out;
integer.c:int bv_cmp_i(BVInteger a, BVInteger b){
integer.c:BVInteger bv_shr_i(BVInteger a, int s){
integer.c:    BVInteger out;
integer.c:BVInteger bv_mod_i(BVInteger *quot, BVInteger a, BVInteger b){
integer.c:    BVInteger quot_temp;
integer.c:    memset(quot, 0, sizeof(BVInteger));
integer.c:BVInteger bv_div_i(BVInteger a, BVInteger b){
integer.c:    BVInteger quot;
integer.c:BVInteger bv_int2i(int64_t a){
integer.c:    BVInteger out;
integer.c:int64_t bv_i2int(BVInteger a){
integer.c:            BVInteger ai= bv_int2i(a);
integer.c:            BVInteger bi= bv_int2i(b);
integer.h:typedef struct BVInteger{
integer.h:} BVInteger;
integer.h:BVInteger bv_add_i(BVInteger a, BVInteger b) bv_const;
integer.h:BVInteger bv_sub_i(BVInteger a, BVInteger b) bv_const;
integer.h: * BVInteger. This is simply the index of the most significant bit
integer.h:int bv_log2_i(BVInteger a) bv_const;
integer.h:BVInteger bv_mul_i(BVInteger a, BVInteger b) bv_const;
integer.h:int bv_cmp_i(BVInteger a, BVInteger b) bv_const;
integer.h:BVInteger bv_shr_i(BVInteger a, int s) bv_const;
integer.h:BVInteger bv_mod_i(BVInteger *quot, BVInteger a, BVInteger b);
integer.h:BVInteger bv_div_i(BVInteger a, BVInteger b) bv_const;
integer.h: * Convert the given int64_t to an BVInteger.
integer.h:BVInteger bv_int2i(int64_t a) bv_const;
integer.h: * Convert the given BVInteger to an int64_t.
integer.h: * If the BVInteger is too large to fit into an int64_t,
integer.h:int64_t bv_i2int(BVInteger a) bv_const;
internal.h:#if HAVE_PRAGMA_DEPRECATED
internal.h:#if HAVE_LOCAL_ALIGNED_8
internal.h:#if HAVE_LOCAL_ALIGNED_16
internal.h:#if HAVE_LOCAL_ALIGNED_32
internal.h: * (for example BVCodec long_names).
internal.h:#if HAVE_SYMVER_ASM_LABEL
internal.h:#elif HAVE_SYMVER_GNU_ASM
internal.h: * Used to disable threading functions in BVCodec definitions
internal.h:#if HAVE_THREADS
internal.h:#if HAVE_LIBC_MSVCRT
internal.h:int bvpriv_set_systematic_pal2(uint32_t pal[256], enum BVPixelFormat pix_fmt);
intmath.h:#if HAVE_FAST_CLZ
intmath.h:#if HAVE_FAST_CLZ
intreadwrite.h:#ifdef HAVE_BV_CONFIG_H
intreadwrite.h:#elif ARCH_AVR32
intreadwrite.h:#endif /* HAVE_BV_CONFIG_H */
intreadwrite.h:#if BV_HAVE_BIGENDIAN
intreadwrite.h:#else /* BV_HAVE_BIGENDIAN */
intreadwrite.h:#endif /* !BV_HAVE_BIGENDIAN */
intreadwrite.h:#elif BV_HAVE_FAST_UNALIGNED
intreadwrite.h:#if BV_HAVE_BIGENDIAN
intreadwrite.h:#endif /* HAVE_FAST_UNALIGNED */
intreadwrite.h:#if BV_HAVE_BIGENDIAN
匹配到二进制文件 libbvutil.a
匹配到二进制文件 libbvutil.so
匹配到二进制文件 libbvutil.so.
libm.h:#if HAVE_MIPSFPU && HAVE_INLINE_ASM
libm.h:#endif /* HAVE_MIPSFPU && HAVE_INLINE_ASM*/
libm.h:#if !HAVE_ATANF
libm.h:#if !HAVE_ATAN2F
libm.h:#if !HAVE_POWF
libm.h:#if !HAVE_CBRT
libm.h:#if !HAVE_CBRTF
libm.h:#if !HAVE_COSF
libm.h:#if !HAVE_EXPF
libm.h:#if !HAVE_EXP2
libm.h:#endif /* HAVE_EXP2 */
libm.h:#if !HAVE_EXP2F
libm.h:#endif /* HAVE_EXP2F */
libm.h:#if !HAVE_ISINF
libm.h:#endif /* HAVE_ISINF */
libm.h:#if !HAVE_ISNAN
libm.h:#endif /* HAVE_ISNAN */
libm.h:#if !HAVE_LDEXPF
libm.h:#if !HAVE_LLRINT
libm.h:#endif /* HAVE_LLRINT */
libm.h:#if !HAVE_LLRINTF
libm.h:#endif /* HAVE_LLRINT */
libm.h:#if !HAVE_LOG2
libm.h:#endif /* HAVE_LOG2 */
libm.h:#if !HAVE_LOG2F
libm.h:#endif /* HAVE_LOG2F */
libm.h:#if !HAVE_LOG10F
libm.h:#if !HAVE_SINF
libm.h:#if !HAVE_RINT
libm.h:#endif /* HAVE_RINT */
libm.h:#if !HAVE_LRINT
libm.h:#endif /* HAVE_LRINT */
libm.h:#if !HAVE_LRINTF
libm.h:#endif /* HAVE_LRINTF */
libm.h:#if !HAVE_ROUND
libm.h:#endif /* HAVE_ROUND */
libm.h:#if !HAVE_ROUNDF
libm.h:#endif /* HAVE_ROUNDF */
libm.h:#if !HAVE_TRUNC
libm.h:#endif /* HAVE_TRUNC */
libm.h:#if !HAVE_TRUNCF
libm.h:#endif /* HAVE_TRUNCF */
log.c:#if HAVE_UNISTD_H
log.c:#if HAVE_IO_H
log.c:#if HAVE_PTHREADS
log.c:#if defined(_WIN32) && !defined(__MINGW32CE__) && HAVE_SETCONSOLETEXTATTRIBUTE
log.c:#if defined(_WIN32) && !defined(__MINGW32CE__) && HAVE_SETCONSOLETEXTATTRIBUTE
log.c:#elif HAVE_ISATTY
log.c:#if defined(_WIN32) && !defined(__MINGW32CE__) && HAVE_SETCONSOLETEXTATTRIBUTE
log.c:                        BVBPrint part[4], int *print_prefix, int type[2])
log.c:    BVBPrint part[4];
log.c:    BVBPrint part[4];
log.c:#if HAVE_PTHREADS
log.c:#if HAVE_ISATTY
log.c:#if HAVE_PTHREADS
log.h: * BVClass struct (e.g. BVCodecContext, BVFormatContext etc.).
log.h:     * logging is stored. For example a decoder could pass its BVCodecContext
匹配到二进制文件 log.o
Makefile:SLIBOBJS-$(HAVE_GNU_WINDRES)            += bvutilres.o
Makefile:SKIPHEADERS-$(HAVE_ATOMICS_GCC)        += atomic_gcc.h
Makefile:SKIPHEADERS-$(HAVE_ATOMICS_SUNCC)      += atomic_suncc.h
Makefile:SKIPHEADERS-$(HAVE_ATOMICS_WIN32)      += atomic_win32.h
Makefile:TESTPROGS-$(HAVE_LZO1X_999_COMPRESS) += lzo
mathematics.c:int64_t bv_rescale_rnd(int64_t a, int64_t b, int64_t c, enum BVRounding rnd)
mathematics.c:        BVInteger ai;
mathematics.c:                         enum BVRounding rnd)
mathematics.h:enum BVRounding {
mathematics.h:int64_t bv_rescale_rnd(int64_t a, int64_t b, int64_t c, enum BVRounding) bv_const;
mathematics.h:                         enum BVRounding) bv_const;
匹配到二进制文件 mathematics.o
md5.c:typedef struct AVMD5{
md5.c:} AVMD5;
md5.c:const int bv_md5_size = sizeof(AVMD5);
md5.c:struct AVMD5 *bv_md5_alloc(void)
md5.c:    return bv_mallocz(sizeof(struct AVMD5));
md5.c:#if HAVE_BIGENDIAN
md5.c:void bv_md5_init(AVMD5 *ctx)
md5.c:void bv_md5_update(AVMD5 *ctx, const uint8_t *src, int len)
md5.c:    if (HAVE_BIGENDIAN || (!HAVE_FAST_UNALIGNED && ((intptr_t)src & 3))) {
md5.c:void bv_md5_final(AVMD5 *ctx, uint8_t *dst)
md5.c:    AVMD5 ctx;
md5.h:struct AVMD5;
md5.h: * Allocate an AVMD5 context.
md5.h:struct AVMD5 *bv_md5_alloc(void);
md5.h:void bv_md5_init(struct AVMD5 *ctx);
md5.h:void bv_md5_update(struct AVMD5 *ctx, const uint8_t *src, int len);
md5.h:void bv_md5_final(struct AVMD5 *ctx, uint8_t *dst);
匹配到二进制文件 md5.o
mem.c:#if HAVE_MALLOC_H
mem.c:#define ALIGN (HAVE_AVX ? 32 : 16)
mem.c:#elif HAVE_POSIX_MEMALIGN
mem.c:#elif HAVE_ALIGNED_MALLOC
mem.c:#elif HAVE_MEMALIGN
mem.c:     * For AVX ASM. SSE / NEON needs only 16.
mem.c:#elif HAVE_ALIGNED_MALLOC
mem.c:#elif HAVE_ALIGNED_MALLOC
mem.c:#if HAVE_BIGENDIAN
motion_vector.h:typedef struct AVMotionVector {
motion_vector.h:} AVMotionVector;
murmur3.c:typedef struct AVMurMur3 {
murmur3.c:} AVMurMur3;
murmur3.c:AVMurMur3 *bv_murmur3_alloc(void)
murmur3.c:    return bv_mallocz(sizeof(AVMurMur3));
murmur3.c:void bv_murmur3_init_seeded(AVMurMur3 *c, uint64_t seed)
murmur3.c:void bv_murmur3_init(AVMurMur3 *c)
murmur3.c:void bv_murmur3_update(AVMurMur3 *c, const uint8_t *src, int len)
murmur3.c:void bv_murmur3_final(AVMurMur3 *c, uint8_t dst[16])
murmur3.c:    AVMurMur3 *ctx = bv_murmur3_alloc();
murmur3.h:struct AVMurMur3 *bv_murmur3_alloc(void);
murmur3.h:void bv_murmur3_init_seeded(struct AVMurMur3 *c, uint64_t seed);
murmur3.h:void bv_murmur3_init(struct AVMurMur3 *c);
murmur3.h:void bv_murmur3_update(struct AVMurMur3 *c, const uint8_t *src, int len);
murmur3.h:void bv_murmur3_final(struct AVMurMur3 *c, uint8_t dst[16]);
匹配到二进制文件 murmur3.o
old_pix_fmts.h: * Do not add new items to this list. Use the BVPixelFormat enum instead.
opencl.c:#if HAVE_THREADS
opencl.c:#if HAVE_PTHREADS
opencl.c:#elif HAVE_W32THREADS
opencl.c:#elif HAVE_OS2THREADS
opencl.c:     * passed as BVOpenCLExternalEnv when initing ,0:created by opencl wrapper.
opencl.c:    BVOpenCLDeviceList device_list;
opencl.c:    {CL_DEVICE_NOT_BVAILABLE,                           "DEVICE NOT BVAILABLE"},
opencl.c:    {CL_COMPILER_NOT_BVAILABLE,                         "COMPILER NOT BVAILABLE"},
opencl.c:    {CL_PROFILING_INFO_NOT_BVAILABLE,                   "PROFILING INFO NOT BVAILABLE"},
opencl.c:    {CL_LINKER_NOT_BVAILABLE,                           "LINKER NOT BVAILABLE"},
opencl.c:    {CL_KERNEL_ARG_INFO_NOT_BVAILABLE,                  "KERNEL ARG INFO NOT BVAILABLE"},
opencl.c:static void free_device_list(BVOpenCLDeviceList *device_list)
opencl.c:static int get_device_list(BVOpenCLDeviceList *device_list)
opencl.c:    BVOpenCLDeviceNode *device_node = NULL;
opencl.c:    device_list->platform_node = bv_mallocz_array(device_list->platform_num, sizeof(BVOpenCLPlatformNode *));
opencl.c:        device_list->platform_node[i] = bv_mallocz(sizeof(BVOpenCLPlatformNode));
opencl.c:        device_list->platform_node[i]->device_node = bv_mallocz_array(total_devices_num, sizeof(BVOpenCLDeviceNode *));
opencl.c:                    device_list->platform_node[i]->device_node[device_num] = bv_mallocz(sizeof(BVOpenCLDeviceNode));
opencl.c:int bv_opencl_get_device_list(BVOpenCLDeviceList **device_list)
opencl.c:    *device_list = bv_mallocz(sizeof(BVOpenCLDeviceList));
opencl.c:void bv_opencl_free_device_list(BVOpenCLDeviceList **device_list)
opencl.c:#if HAVE_THREADS
opencl.c:BVOpenCLExternalEnv *bv_opencl_alloc_external_env(void)
opencl.c:    BVOpenCLExternalEnv *ext = bv_mallocz(sizeof(BVOpenCLExternalEnv));
opencl.c:void bv_opencl_free_external_env(BVOpenCLExternalEnv **ext_opencl_env)
opencl.c:static int init_opencl_env(OpenclContext *opencl_ctx, BVOpenCLExternalEnv *ext_opencl_env)
opencl.c:    BVOpenCLDeviceNode *device_node = NULL;
opencl.c:int bv_opencl_init(BVOpenCLExternalEnv *ext_opencl_env)
opencl.c:int64_t bv_opencl_benchmark(BVOpenCLDeviceNode *device_node, cl_platform_id platform,
opencl.c:                            int64_t (*benchmark)(BVOpenCLExternalEnv *ext_opencl_env))
opencl.c:    BVOpenCLExternalEnv *ext_opencl_env = NULL;
opencl.h:#if HAVE_CL_CL_H
opencl.h:} BVOpenCLDeviceNode;
opencl.h:    BVOpenCLDeviceNode **device_node;
opencl.h:} BVOpenCLPlatformNode;
opencl.h:    BVOpenCLPlatformNode **platform_node;
opencl.h:} BVOpenCLDeviceList;
opencl.h:} BVOpenCLExternalEnv;
opencl.h:int bv_opencl_get_device_list(BVOpenCLDeviceList **device_list);
opencl.h:void bv_opencl_free_device_list(BVOpenCLDeviceList **device_list);
opencl.h:BVOpenCLExternalEnv *bv_opencl_alloc_external_env(void);
opencl.h:void bv_opencl_free_external_env(BVOpenCLExternalEnv **ext_opencl_env);
opencl.h:int bv_opencl_init(BVOpenCLExternalEnv *ext_opencl_env);
opencl.h:int64_t bv_opencl_benchmark(BVOpenCLDeviceNode *device, cl_platform_id platform,
opencl.h:                            int64_t (*benchmark)(BVOpenCLExternalEnv *ext_opencl_env));
opt.c:#if FF_API_OLD_BVOPTIONS
opt.c:#if FF_API_OLD_BVOPTIONS
opt.c:#if FF_API_OLD_BVOPTIONS
opt.c:int bv_opt_set_pixel_fmt(void *obj, const char *name, enum BVPixelFormat fmt, int search_flags)
opt.c:#if FF_API_OLD_BVOPTIONS
opt.c:        ret = snprintf(buf, sizeof(buf), "%s", (char *)bv_x_if_null(bv_get_pix_fmt_name(*(enum BVPixelFormat *)dst), "none"));
opt.c:#if FF_API_OLD_BVOPTIONS
opt.c:int bv_opt_get_pixel_fmt(void *obj, const char *name, int search_flags, enum BVPixelFormat *out_fmt)
opt.c:#if FF_API_OLD_BVOPTIONS
opt.c:#if FF_API_OLD_BVOPTIONS
opt.c:    case BV_OPT_TYPE_PIXEL_FMT: return sizeof(enum BVPixelFormat);
opt.c:    BVBPrint bprint;
opt.c:    enum BVPixelFormat pix_fmt;
opt.h: *      BVOptions-enabled struct as a member (e.g. BVCodecContext in
opt.h: *      iterates over all possible child classes. E.g. if an BVCodecContext
opt.h: *      child_next() will return BVCodecContext.priv_data and finish
opt.h: *      iterating. OTOH child_class_next() on BVCodecContext.bv_class will
opt.h: * Such structs in BVbase are e.g. BVCodecContext in libavcodec or
opt.h: * BVFormatContext in libavformat.
opt.h:#if FF_API_OLD_BVOPTIONS
opt.h:#if FF_API_OLD_BVOPTIONS
opt.h:#if FF_API_OLD_BVOPTIONS
opt.h:int bv_opt_set_pixel_fmt (void *obj, const char *name, enum BVPixelFormat fmt, int search_flags);
opt.h:int bv_opt_get_pixel_fmt (void *obj, const char *name, int search_flags, enum BVPixelFormat *out_fmt);
匹配到二进制文件 opt.o
pixdesc.c:                        const BVPixFmtDescriptor *desc,
pixdesc.c:    BVComponentDescriptor comp = desc->comp[c];
pixdesc.c:                         const BVPixFmtDescriptor *desc,
pixdesc.c:    BVComponentDescriptor comp = desc->comp[c];
pixdesc.c:const BVPixFmtDescriptor bv_pix_fmt_descriptors[BV_PIX_FMT_NB] = {
pixdesc.c:static enum BVPixelFormat get_pix_fmt_internal(const char *name)
pixdesc.c:    enum BVPixelFormat pix_fmt;
pixdesc.c:const char *bv_get_pix_fmt_name(enum BVPixelFormat pix_fmt)
pixdesc.c:#if HAVE_BIGENDIAN
pixdesc.c:enum BVPixelFormat bv_get_pix_fmt(const char *name)
pixdesc.c:    enum BVPixelFormat pix_fmt;
pixdesc.c:int bv_get_bits_per_pixel(const BVPixFmtDescriptor *pixdesc)
pixdesc.c:int bv_get_padded_bits_per_pixel(const BVPixFmtDescriptor *pixdesc)
pixdesc.c:        const BVComponentDescriptor *comp = &pixdesc->comp[c];
pixdesc.c:                            enum BVPixelFormat pix_fmt)
pixdesc.c:        const BVPixFmtDescriptor *pixdesc = &bv_pix_fmt_descriptors[pix_fmt];
pixdesc.c:const BVPixFmtDescriptor *bv_pix_fmt_desc_get(enum BVPixelFormat pix_fmt)
pixdesc.c:const BVPixFmtDescriptor *bv_pix_fmt_desc_next(const BVPixFmtDescriptor *prev)
pixdesc.c:enum BVPixelFormat bv_pix_fmt_desc_get_id(const BVPixFmtDescriptor *desc)
pixdesc.c:int bv_pix_fmt_get_chroma_sub_sample(enum BVPixelFormat pix_fmt,
pixdesc.c:    const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(pix_fmt);
pixdesc.c:int bv_pix_fmt_count_planes(enum BVPixelFormat pix_fmt)
pixdesc.c:    const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(pix_fmt);
pixdesc.c:        const BVPixFmtDescriptor *d = &bv_pix_fmt_descriptors[i];
pixdesc.c:            const BVComponentDescriptor *c = &d->comp[j];
pixdesc.c:enum BVPixelFormat bv_pix_fmt_swap_endianness(enum BVPixelFormat pix_fmt)
pixdesc.c:    const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(pix_fmt);
pixdesc.c:static int get_color_type(const BVPixFmtDescriptor *desc) {
pixdesc.c:static int get_pix_fmt_depth(int *min, int *max, enum BVPixelFormat pix_fmt)
pixdesc.c:    const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(pix_fmt);
pixdesc.c:static int get_pix_fmt_score(enum BVPixelFormat dst_pix_fmt,
pixdesc.c:                              enum BVPixelFormat src_pix_fmt,
pixdesc.c:    const BVPixFmtDescriptor *src_desc = bv_pix_fmt_desc_get(src_pix_fmt);
pixdesc.c:    const BVPixFmtDescriptor *dst_desc = bv_pix_fmt_desc_get(dst_pix_fmt);
pixdesc.c:int bv_get_pix_fmt_loss(enum BVPixelFormat dst_pix_fmt,
pixdesc.c:                            enum BVPixelFormat src_pix_fmt,
pixdesc.c:enum BVPixelFormat bv_find_best_pix_fmt_of_2(enum BVPixelFormat dst_pix_fmt1, enum BVPixelFormat dst_pix_fmt2,
pixdesc.c:                                             enum BVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
pixdesc.c:    enum BVPixelFormat dst_pix_fmt;
pixdesc.c:    const BVPixFmtDescriptor *desc1 = bv_pix_fmt_desc_get(dst_pix_fmt1);
pixdesc.c:    const BVPixFmtDescriptor *desc2 = bv_pix_fmt_desc_get(dst_pix_fmt2);
pixdesc.c:const char *bv_color_range_name(enum BVColorRange range)
pixdesc.c:const char *bv_color_transfer_name(enum BVColorTransferCharacteristic transfer)
pixdesc.c:const char *bv_color_space_name(enum BVColorSpace space)
pixdesc.c:const char *bv_chroma_location_name(enum BVChromaLocation location)
pixdesc.c:        const BVPixFmtDescriptor *desc = bv_pix_fmt_desc_get(i);
pixdesc.h:typedef struct BVComponentDescriptor {
pixdesc.h:} BVComponentDescriptor;
pixdesc.h: *       and all the YUV variants) BVPixFmtDescriptor just stores how values
pixdesc.h:typedef struct BVPixFmtDescriptor {
pixdesc.h:    BVComponentDescriptor comp[4];
pixdesc.h:} BVPixFmtDescriptor;
pixdesc.h:extern attribute_deprecated const BVPixFmtDescriptor bv_pix_fmt_descriptors[];
pixdesc.h:                        const int linesize[4], const BVPixFmtDescriptor *desc,
pixdesc.h:                         const int linesize[4], const BVPixFmtDescriptor *desc,
pixdesc.h:enum BVPixelFormat bv_get_pix_fmt(const char *name);
pixdesc.h:const char *bv_get_pix_fmt_name(enum BVPixelFormat pix_fmt);
pixdesc.h:                            enum BVPixelFormat pix_fmt);
pixdesc.h:int bv_get_bits_per_pixel(const BVPixFmtDescriptor *pixdesc);
pixdesc.h:int bv_get_padded_bits_per_pixel(const BVPixFmtDescriptor *pixdesc);
pixdesc.h:const BVPixFmtDescriptor *bv_pix_fmt_desc_get(enum BVPixelFormat pix_fmt);
pixdesc.h:const BVPixFmtDescriptor *bv_pix_fmt_desc_next(const BVPixFmtDescriptor *prev);
pixdesc.h: * @return an BVPixelFormat id described by desc, or BV_PIX_FMT_NONE if desc
pixdesc.h:enum BVPixelFormat bv_pix_fmt_desc_get_id(const BVPixFmtDescriptor *desc);
pixdesc.h: * the pixel format BVPixFmtDescriptor.
pixdesc.h:int bv_pix_fmt_get_chroma_sub_sample(enum BVPixelFormat pix_fmt,
pixdesc.h:int bv_pix_fmt_count_planes(enum BVPixelFormat pix_fmt);
pixdesc.h:enum BVPixelFormat bv_pix_fmt_swap_endianness(enum BVPixelFormat pix_fmt);
pixdesc.h:int bv_get_pix_fmt_loss(enum BVPixelFormat dst_pix_fmt,
pixdesc.h:                        enum BVPixelFormat src_pix_fmt,
pixdesc.h:enum BVPixelFormat bv_find_best_pix_fmt_of_2(enum BVPixelFormat dst_pix_fmt1, enum BVPixelFormat dst_pix_fmt2,
pixdesc.h:                                             enum BVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr);
pixdesc.h:const char *bv_color_range_name(enum BVColorRange range);
pixdesc.h:const char *bv_color_transfer_name(enum BVColorTransferCharacteristic transfer);
pixdesc.h:const char *bv_color_space_name(enum BVColorSpace space);
pixdesc.h:const char *bv_chroma_location_name(enum BVChromaLocation location);
匹配到二进制文件 pixdesc.o
pixfmt.h:#define BVPALETTE_SIZE 1024
pixfmt.h:#define BVPALETTE_COUNT 256
pixfmt.h:enum BVPixelFormat {
pixfmt.h:    BV_PIX_FMT_YUVA422P_LIBAV,  ///< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)
pixfmt.h:    BV_PIX_FMT_YUVA444P_LIBAV,  ///< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)
pixfmt.h:    BV_PIX_FMT_RGBA64BE_LIBAV,     ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
pixfmt.h:    BV_PIX_FMT_RGBA64LE_LIBAV,     ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
pixfmt.h:    BV_PIX_FMT_BGRA64BE_LIBAV,     ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
pixfmt.h:    BV_PIX_FMT_BGRA64LE_LIBAV,     ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
pixfmt.h:#if BV_HAVE_INCOMPATIBLE_LIBBV_ABI
pixfmt.h:#define BV_PIX_FMT_YUVA422P BV_PIX_FMT_YUVA422P_LIBAV
pixfmt.h:#define BV_PIX_FMT_YUVA444P BV_PIX_FMT_YUVA444P_LIBAV
pixfmt.h:#define BV_PIX_FMT_RGBA64BE BV_PIX_FMT_RGBA64BE_LIBAV
pixfmt.h:#define BV_PIX_FMT_RGBA64LE BV_PIX_FMT_RGBA64LE_LIBAV
pixfmt.h:#define BV_PIX_FMT_BGRA64BE BV_PIX_FMT_BGRA64BE_LIBAV
pixfmt.h:#define BV_PIX_FMT_BGRA64LE BV_PIX_FMT_BGRA64LE_LIBAV
pixfmt.h:#if BV_HAVE_BIGENDIAN
pixfmt.h:#define PixelFormat BVPixelFormat
pixfmt.h:enum BVColorTransferCharacteristic {
pixfmt.h:enum BVColorSpace {
pixfmt.h:enum BVColorRange {
pixfmt.h:enum BVChromaLocation {
random_seed.c:#if HAVE_UNISTD_H
random_seed.c:#if HAVE_IO_H
random_seed.c:#if HAVE_CRYPTGENRANDOM
random_seed.c:#if HAVE_UNISTD_H
random_seed.c:#if HAVE_CRYPTGENRANDOM
匹配到二进制文件 rational.o
rc4.c:typedef struct BVRC4 BVRC4;
rc4.c:int bv_rc4_init(BVRC4 *r, const uint8_t *key, int key_bits, int decrypt) {
rc4.c:void bv_rc4_crypt(BVRC4 *r, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt) {
rc4.h:struct BVRC4 {
rc4.h: * @brief Initializes an BVRC4 context.
rc4.h:int bv_rc4_init(struct BVRC4 *d, const uint8_t *key, int key_bits, int decrypt);
rc4.h:void bv_rc4_crypt(struct BVRC4 *d, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt);
匹配到二进制文件 rc4.o
匹配到二进制文件 stereo3d.o
thread.h:#if HAVE_PTHREADS || HAVE_W32THREADS || HAVE_OS2THREADS
thread.h:#if HAVE_PTHREADS
thread.h:#elif HAVE_OS2THREADS
thread.h:#define AVMutex pthread_mutex_t
thread.h:#define AVMutex char
threadmessage.c:#if HAVE_THREADS
threadmessage.c:#if HAVE_PTHREADS
threadmessage.c:#elif HAVE_W32THREADS
threadmessage.c:#elif HAVE_OS2THREADS
threadmessage.c:struct AVThreadMessageQueue {
threadmessage.c:#if HAVE_THREADS
threadmessage.c:    BVFifoBuffer *fifo;
threadmessage.c:int bv_thread_message_queue_alloc(AVThreadMessageQueue **mq,
threadmessage.c:#if HAVE_THREADS
threadmessage.c:    AVThreadMessageQueue *rmq;
threadmessage.c:#endif /* HAVE_THREADS */
threadmessage.c:void bv_thread_message_queue_free(AVThreadMessageQueue **mq)
threadmessage.c:#if HAVE_THREADS
threadmessage.c:#if HAVE_THREADS
threadmessage.c:static int bv_thread_message_queue_send_locked(AVThreadMessageQueue *mq,
threadmessage.c:static int bv_thread_message_queue_recv_locked(AVThreadMessageQueue *mq,
threadmessage.c:#endif /* HAVE_THREADS */
threadmessage.c:int bv_thread_message_queue_send(AVThreadMessageQueue *mq,
threadmessage.c:#if HAVE_THREADS
threadmessage.c:#endif /* HAVE_THREADS */
threadmessage.c:int bv_thread_message_queue_recv(AVThreadMessageQueue *mq,
threadmessage.c:#if HAVE_THREADS
threadmessage.c:#endif /* HAVE_THREADS */
threadmessage.c:void bv_thread_message_queue_set_err_send(AVThreadMessageQueue *mq,
threadmessage.c:#if HAVE_THREADS
threadmessage.c:#endif /* HAVE_THREADS */
threadmessage.c:void bv_thread_message_queue_set_err_recv(AVThreadMessageQueue *mq,
threadmessage.c:#if HAVE_THREADS
threadmessage.c:#endif /* HAVE_THREADS */
threadmessage.h:typedef struct AVThreadMessageQueue AVThreadMessageQueue;
threadmessage.h:typedef enum AVThreadMessageFlags {
threadmessage.h:} AVThreadMessageFlags;
threadmessage.h:int bv_thread_message_queue_alloc(AVThreadMessageQueue **mq,
threadmessage.h:void bv_thread_message_queue_free(AVThreadMessageQueue **mq);
threadmessage.h:int bv_thread_message_queue_send(AVThreadMessageQueue *mq,
threadmessage.h:int bv_thread_message_queue_recv(AVThreadMessageQueue *mq,
threadmessage.h:void bv_thread_message_queue_set_err_send(AVThreadMessageQueue *mq,
threadmessage.h:void bv_thread_message_queue_set_err_recv(AVThreadMessageQueue *mq,
匹配到二进制文件 threadmessage.o
time.c:#if HAVE_GETTIMEOFDAY
time.c:#if HAVE_UNISTD_H
time.c:#if HAVE_WINDOWS_H
time.c:#if HAVE_GETTIMEOFDAY
time.c:#elif HAVE_GETSYSTEMTIMEASFILETIME
time.c:#if HAVE_CLOCK_GETTIME && defined(CLOCK_MONOTONIC)
time.c:#if HAVE_CLOCK_GETTIME && defined(CLOCK_MONOTONIC)
time.c:#if HAVE_NANOSLEEP
time.c:#elif HAVE_USLEEP
time.c:#elif HAVE_SLEEP
time_internal.h:#if !HAVE_GMTIME_R && !defined(gmtime_r)
time_internal.h:#if !HAVE_LOCALTIME_R && !defined(localtime_r)
timer.h:#if HAVE_MACH_MACH_TIME_H
timer.h:#   if HAVE_GETHRTIME
timer.h:#   elif HAVE_MACH_ABSOLUTE_TIME
tree.h: * @addtogroup lavu_tree AVTree
utils.c:    bv_assert0(HAVE_MMX2 == HAVE_MMXEXT);
utils.c:const char *bv_get_media_type_string(enum BVMediaType media_type)
utils.c:char bv_get_picture_type_char(enum BVPictureType pict_type)
匹配到二进制文件 utils.o
version.h:#ifndef FF_API_OLD_BVOPTIONS
version.h:#define FF_API_OLD_BVOPTIONS            (LIBBVUTIL_VERSION_MAJOR < 55)
version.h:#ifndef FF_API_BVFRAME_LBVC
version.h:#define FF_API_BVFRAME_LBVC             (LIBBVUTIL_VERSION_MAJOR < 55)
